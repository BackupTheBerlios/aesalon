\documentclass[a4paper,10pt]{report}
\usepackage[utf8x]{inputenc}

\author{strange\\kawk256@gmail.com}
\title{Internals of the Aesalon visualization tool\\\normalsize{Version 0.1}}

\begin{document}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

% Prevent 'Aesalon' from being broken by hyphenation.
\hyphenation{Aesalon}

\maketitle

\tableofcontents

\chapter[Overview]{An overview of Aesalon}
\section{Introduction}
Aesalon is a tool to visualize, in real-time or non, various aspects of a program.
The specific aspects visualized depend upon the modules specified when invoking Aesalon
upon an unsuspecting program. \footnote{Aesalon strives to reduce the impact upon the
monitored program; much of the time there should be only nominal changes in its behaviour.}
The data supplied may range from per-thread CPU utilization to lifetime data on the allocated
blocks of memory; referenced shared libraries, network connection utilization and file-descriptor
information. These types of information have three primary applications \ldots

\subsection{Optimization}
One can call the primary utilization of Aesalon the function of optimization. Having access to a
full description of exactly where and how a program is utilizing not only its CPU time, but also
its memory, network connections, timers, shared libraries, and other such data can be invaluable
for tracking down issues both esoteric and not.

\subsection{Leaked resources}
With some types of modules (memory block tracking and file descriptor tracking, for two examples),
it is possible to track where resources are allocated by a process. If this process does not release
these resources, once allocated, then the allocation history can prove useful.

\subsection{Pure interest}
What programmer does not want to know exactly how their program is behaving? Such information can be
not only useful, but also interesting.

\section{Implementation layout}
\subsection{The Aesalon framework}
The Aesalon framework is segregated into two separate sections.
\flushleft
\begin{description}
 \item[\textnormal{The} Monitor] is responsible for launching the process in question. It also loads the monitor modules
  and parses any ELF and DWARF information present inside the executable file. Any data processed by the
  monitor modules is then sent over a network connection to the Visualizer and/or written to a logfile.
 \item[\textnormal{The} Visualizer] loads the visualizer modules and provides storage and rendering frameworks for the
  modules.
\end{description}

Overall, the framework is relatively bare-bones; much of the processing etc. is done by the modules themselves.

\subsection{The modules}
Each module is split into three separate sections.
\flushleft
\begin{description}
 \item[\textnormal{The} Collector module] is loaded into the address space of the process being monitored; as such, the
  data is collected here, and transferred to the Monitor by a shared memory map.
 \item[\textnormal{The} Monitor module] is loaded by the Monitor into the Monitor's address space. Here, the raw data collected
  by the Collector is refined slightly. For example, raw function addresses might be processed into C-style
  scope names.
 \item[\textnormal{The} Visualizer module] stores and visualizes the data processed by the monitor; it is loaded into the address
  space of the Visualizer.
\end{description}

\section{Communication methods used}
Several methods are used to communicate between the various sections.
\flushleft
\begin{description}
 \item[SHM (SHared Memory)] is used to communicate between the Collector modules and the Monitor;
 \item[\textnormal{A} TCP network socket] is used to communicate between the Monitor and Visualizer when operating in
  real-time mode.
\end{description}

\chapter{Implementation details}
\section{The Program Monitor}
\subsection{High-level Overview}
The Program Monitor can be termed the core of the data collection system in Aesalon. It is responsible for
launching the process, loading the various collection modules, parsing the executable's ELF and DWARF data,
and loading the monitor modules.

\subsection{Command-line invocation}
Provided, in alphabetical order, are the command-line options for the program monitor. The general form
for invocation is \texttt{aesalon [options] [--] filename [arguments]}.
\begin{description}
 \item[\texttt{--collector:} (group *)] Provides the module-specific paths to the collector shared library, relative to the module's
  root directory.
 \item[\texttt{--help:}] Displays an automatically-generated list of options, with brief descriptions.
 \item[\texttt{--log-file:}] If set, specifies a file to write events to. \texttt{.alog} is the standardized extension.
 \item[\texttt{--mconfig:} (group *)] Module-specific configurations. Can be used to set timers, disallow collection of certain types of data, etc.
 \item[\texttt{--modules:}] A colon-separated list of modules to load.
 \item[\texttt{--monitor:} (group *)] Provides the module-specific paths to the monitor shared library, relative to the module's
  root directory.
 \item[\texttt{--network-wait:}] The number of network clients to wait for a connection from before commencing execution.
 \item[\texttt{--search-path:}] A colon-separated list of paths to search for module root directories in.
 \item[\texttt{--shm-size:}] The size of the SHM to use; must be a multiple of the page size of the operating system.%
  \footnote{Typically 4096 bytes on x86 and x86\_64 Linux systems.}
 \item[\texttt{--tcp-port:}] The TCP port to listen on for client connections.
\end{description}
\small{Items marked with a * are groups, a special type of argument. Each group has multiple sub-options, optionally specified.}

\subsection{Configuration}
There are five different levels of configuration, presented in order of processing.
\begin{description}
 \item[Global configuration] is the system-wide defaults. The default path is \texttt{/etc/default/aesalon.conf.}
 \item[User configuration] is the user-wide defaults. The default path is \texttt{$\sim$/.config/aesalon/aesalon.conf.}
 \item[Local configuration] is the directory. This is a special case; any file named (by default) \texttt{.aesalon.conf}
  will be parsed and applied to any instances launched from that directory.
 \item[Module configuration] applies a default range of settings on a module-wide basis. These files are located in the module root, 
  called \texttt{monitor.conf}.
 \item[Command-line arguments] are the final level of configuration. These override all other configurations, and are specified
  on the command-line.
\end{description}

\begin{figure}[h]
 \caption{Example global configuration file.\label{exampleconfigfile}}
 \begin{verbatim}
search-path=/usr/share/aesalon/modules/:
shm-size=1048576
tcp-port=6321
 \end{verbatim}

\end{figure}

In configuration files, options are specified as demonstrated in Figure \ref{exampleconfigfile}. Additionally, \texttt{+=} may be used
to concatenate the content of an option that is specified in two separate locations. This behaviour is identical to that of the
command-line\footnote{e.g. \texttt{--modules+=cpuTime:} is perfectly valid behaviour.}.

\section{Design}
\subsection{Source layout}
The monitor is designed in a somewhat logical manner. The source is separated into directories, each of which handles a specific
set of duties.

\begin{description}
 \item[.:] contains the ``essential'' files; the generic, global sources, if you will.
 \item[program:] contains source files relating to execution control and executable analysing.
 \item[network:] has all the network-related source files.
 \item[module:] the monitor module-related source code.
 \item[interface:] the monitor module interface; class definitions and implementations.
 \item[misc:] any miscellaneous/utility classes.
\end{description}

\subsection{Threads}

There are two primary threads in the monitor:
\begin{description}
 \item[\textnormal{The} main thread] handles all initialization (including executable parsing), then eventually calls \emph{wait()} on
  the monitored process.
 \item[\textnormal{The} reader thread] reads from the SHM, processes the data packets via the monitor module, logs the packets to a log
  file if applicable, then sends the packets via the network socket to any connected visualizers.
\end{description}

\chapter{Module API}
The module API is relatively dynamic; changes both minor and major may be made without much warning. Detailed here are the
current module APIs.
\section{Collector}
The Collector API is very minimalistic. 
\section{Monitor}
The Monitor API is only partially completed at the moment.
\section{Visualizer}
The Visualizer API is very simple in concept, rather more complex in practice.

\appendix

\chapter{Version History}
\begin{description}
 \item[Version 0.1] Initial version of this document.
\end{description}

\chapter{Author Contact information}
The author of this document can be reached at \texttt{kawk256@gmail.com}.

\end{document}
