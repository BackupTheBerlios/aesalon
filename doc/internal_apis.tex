\hyphenation{Visualization Renderer}

\chapter{Module APIs}
The module APIs are currently relatively dynamic; changes both minor and major may be made without much warning.
Detailed here are the current module APIs.

\section{A note on common functionality}
The AC\_Address, AC\_DataPacket, and AC\_Timestamp data types (described in \ref{basicDataTypes}) are also present in
the polisher and renderer module APIs as Address, DataPacket, and Timestamp.

\section{Collector}
The Collector API is very minimalistic. It consists of a \emph{collector interface}, responsible for (among other
duties)
transferring data packets from the various loaded modules into the SHM. Its other duties include timestamp generation,
module configurations, and module management.\footnote{Other various utility functions are also provided to prevent
redundancy amongst module sources.}

\subsection{Naming convention}
The functions provided by the collector module interface have a strict naming convention. To reduce unnecessary
namespace
pollution, it is recommended that module developers follow these naming guidelines.
\begin{description}
 \item[Interface functions] are preceeded by \emph{AC\_} (\emph{A}esalon \emph{C}ollector). For example,
\emph{AC\_timestamp()}
constructs a timestamp representing the current moment.
 \item[Module functions] are preceeded by \emph{ACM\_} (\emph{A}esalon \emph{C}ollector \emph{M}odule). For example,
\emph{ACM\_initializeFunctionPointers()}.
\end{description}

\subsection{Types}
Several types are defined by the collector interface.

\documentType{AC\_Address}{Stores an address. This is a type that is guaraunteed to be at \emph{least} the size of the
type used to reference memory.}{}
\documentType{AC\_Timestamp}{Stores a timestamp value.}
\documentType{AC\_DataPacket}{Encapsulates a packet of data.}
\documentProperty{AC\_DataPacket}{}{dataSource}{An anonymous struct, storing information about the packet's
origins.}
\documentProperty{AC\_DataPacket}{uint16\_t}{dataSource.moduleID}{The module ID\# this packet is associated with.}
\documentProperty{AC\_DataPacket}{uint16\_t}{dataSource.timestamp}{The timestamp associated with this packet, typically
the time the data was collected.}
\documentProperty{AC\_DataPacket}{void *}{data}{The data the packet represents, of size \emph{dataSize}.}
\documentProperty{AC\_DataPacket}{uint32\_t}{dataSize}{The size of \emph{data}.}

\subsection{Module basics}
\label{basicDataTypes}
Before a collector module can send data to its monitor counterpart, it first must be registered and obtain a module ID.
The process is quite simple, fortunately. A pair of functions, or a single macro, are used to perform this task.

\documentFunction{uint16\_t}{AC\_registerModuleInternal}{const char *name}{Internal function, registers a module and
returns its ID.}
\documentFunction{void}{AC\_setModuleID}{uint16\_t id}{Sets the module-wide ID for this module.}

In reality, however, the convenience macro \emph{AC\_registerModule()} should be used.

\documentMacro{AC\_registerModule}{name}{Calls \emph{AC\_registerModuleInternal()} and \emph{AC\_setModuleID()}, in
essence registering a module for use.}

Before \emph{AC\_registerModule()} can be used, however, the module must be defined, creating several internally-used
global variables and functions. The macro \emph{AC\_moduleDefiniton()} is used for this purpose.

\documentMacro{AC\_moduleDefinition}{}{Creates global variables and internally-used functions; should be placed
within the global scope of a single source file per module.}

\subsection{Module communication}
The communication between the collector modules and the monitor is very much a one-sided conversation. The collector
modules can send data to the monitor, but the monitor (and through it, the polisher modules) cannot send any data to
the collector modules.\footnote{A few internally-used flags -- not accessible to collector modules -- notwithstanding.}
Below are the functions that are used to communicate between the collector modules and the monitor.

\documentFunction{void}{AC\_writePacket}{AC\_DataPacket *packet}{Sends an \emph{AC\_DataPacket} to the associated
polisher module via the monitor.}
\documentFunction{uint8\_t}{AC\_hasCollectionBegun}{}{Returns 1 if ``collection has begun''; this currently means only
if main() has been reached. 0 if otherwise.}

\subsection{Module configuration}
The collector modules have a configuration system that chains on to the monitor's; any configuration option specified
on the command-line or in configuration files for the monitor is also accessible by the collector modules. Four
functions are provided for doing so.

\documentFunction{char *}{AC\_configurationString}{const char *module, const char *name}{Returns a constant string
referencing the configuration item \emph{module.name}.}
\documentFunction{int}{AC\_configurationInt}{const char *module, const char *name}{Performs similar duties to
\emph{AC\_configurationString()}, except that the return value is converted into an integer automatically. Zero is
returned if the string could not be converted to an integer, or if the configuration item does not exist. Note there is
currently no way to tell which has occurred.}
\documentFunction{long}{AC\_configurationLong}{const char *module, const char *name}{Performs the same task as
\emph{AC\_configurationInt()}, except the value is converted to a long. Return value semantics are identical.}
\documentFunction{int}{AC\_configurationBool}{const char *module, const char *name}{Takes the configuration value
\emph{module.name} and converts the string value to a bool. Returns a C-style bool; 1 if the string value is ``true'',
0 if ``false''.}

\subsection{Utility functions}
To reduce the amount of redundant code between the various modules, a small set of generic utility functions is
provided. This list will expand in the future.

\documentFunction{AC\_Timestamp}{AC\_timestamp}{}{Returns an \emph{AC\_Timestamp} detailing the current time.}
\documentFunction{AC\_Address}{AC\_libraryOffset}{const char *name}{Returns the address in memory that the library
filename beginning with with \emph{name} is loaded into.}

\section{Polisher}
The Polisher API is only partially completed at the moment; however, the currently-existing API is functional. It just
cannot do very much \ldots

\section{Renderer}
The Renderer API is very simple in concept, rather more complex in practice. The Renderer module has two primary
duties. The first is to take packets received from the associated polisher module, extract the data, and store said
data. The second is to, upon request, render the stored data in a number of ways, specified by the exported Renderers.

\subsection{Data processing and storage}
Data is processed and stored in a \emph{DataCache} instance. There is only one globally-exported function in the
\emph{DataCache} interface; developers are expected to provide their own methods of accessing stored data.\footnote{The
rationale behind this decision is the varying types of data that are stored inside \emph{DataCache}s. The retrieval
interface for CPU usage will be very different than that for, say, thread life.}

\documentType{AbstractDataCache}{Stores the data associated with this module. This class contains pure virtual methods.}
\documentMethod{AbstractDataCache}{void}{processPacket}{DataPacket *packet}{= 0}{The primary method in the derived
classes. This function takes a DataPacket and extracts the data contained within; presumably storing it for later
retrieval.}

\subsection{Data rendering}
Of course, storing data is rather useless without a method to actually display it. Rendering the data is a job done by
\emph{Renderer} classes. Each module may have more than one \emph{Renderer} type; for example, the dynamicMemory module
has a ``density'' visualization and a ``block count'' visualization. Each renderer displays the same data (or perhaps
only a part of the data), simply in a different manner.

\documentType{AbstractRenderer$<$CacheType$>$}{Renders a given range of data in a manner defined by the implementation,
using the \emph{DataCache} type \emph{CacheType}.}
\documentMethod{AbstractRenderer$<$CacheType$>$}{void}{renderRange}{VisualizationWrapper *visualization, const
DataRange \&range, bool *abort}{= 0}{Renders the data range \emph{range} onto \emph{visualization}. When \emph{*abort}
becomes true, then the rendering process may be aborted. If the rendering is aborted, \emph{visualization} is unused and
may be left in a half-rendered state.}
\documentMethod{AbstractRenderer$<$CacheType$>$}{void}{defaultRange}{}{= 0}{Returns the ``default range'' of a
new visualization; this typically encompasses all available data.}
\documentMethod{AbstractRenderer$<$CacheType$>$}{CacheType *}{dataCache}{}{}{Returns the derived
\emph{DataCache} type implemented by the module.}

\subsection{Interfacing with the visualizer}
The third, as-of-yet-not-mentioned section of each renderer module is the \emph{Controller}. Unlike the
\emph{DataCache} and \emph{Renderer} classes, the \emph{Controller} class does not need to be subclassed on a
per-module basis.

A function must be exported by the renderer module called \emph{Instantiate}. This function returns a \emph{Controller}
instance that is then used elsewhere, interally, by the visualizer. Each \emph{Controller} instance needs two things.

\begin{itemize}
  \item A \emph{DataCache} instance.
  \item A \emph{RendererFactory} instance.
\end{itemize}

Renderer modules should never directly create a \emph{RendererFactory} instance; instead, the class
\emph{ConcreteRendererFactory} should be used.

\documentType{ConcreteRendererFactory}{Subclassed \emph{RendererFactory}, used by Renderer modules.}
\documentMethod{ConcreteRendererFactory}{void}{registerRenderer}{std::string name, Renderer *renderer}{}{
  Registers a renderer to be used by the visualizer.
}



%The RendererFactory interface is described below, for reference.
%
%\documentType{RendererFactory}{Used to retrieve \emph{Renderer} instances.}
%\documentMethod{RendererFactory}{Renderer *}{renderer}{const std::string \&name}{= 0}{Returns the renderer with the
%name \emph{name}, or NULL if such a renderer does not exist in this instance.}
%\documentMethod{RendererFactory}{void}{rendererNames}{std::vector<std::string> \&names}{= 0}{Clears, then fills
%\emph{names} with the names of the registered renderers in this instance.}

%virtual Renderer *renderer(const std::string &name) = 0;
%virtual void rendererNames(std::vector<std::string> &names) = 0;

\subsection{Generic utility classes}
Like the collector and polisher modules, the renderer interface provides a number of ``utility'' classes; code that
would otherwise be duplicated inside many of the modules.

\documentType{DataCoord}{A ``data coordinate''; or a set of a timestamp and a double. Used to denote a coordinate on a
visualization.}
\documentType{DataRange}{A pair of \emph{DataCoord}s, used to denote a range of data on a visualization.}
