\chapter{An overview of Aesalon}
\section{Introduction}
\indent Aesalon is a tool to visualize, in real-time or non, various aspects of a program.
The specific aspects visualized depend upon the modules specified when invoking Aesalon
upon an unsuspecting program.\footnote{Aesalon strives to reduce the impact upon the
monitored program; much of the time there should be only nominal changes in its behaviour.}
The data supplied may range from per-thread CPU utilization to lifetime data on the allocated
blocks of memory; referenced shared libraries, network connection utilization and file-descriptor
information. These types of information have three primary applications \ldots

\subsection{Optimization}
One can call the primary utilization of Aesalon the function of optimization. Having access to a
full description of exactly where and how a program is utilizing not only its CPU time, but also
its memory, network connections, timers, shared libraries, and other such data can be invaluable
for tracking down issues both esoteric and not.

\subsection{Leaked resources}
With some types of modules (memory block tracking and file descriptor tracking, for two examples),
it is possible to track where resources are allocated by a process. If this process does not release
these resources, once allocated, then the allocation history can prove useful.

\subsection{Pure interest}
What programmer does not want to know exactly how their program is behaving? Such information can be
not only useful, but also interesting.

\section{Implementation layout}
\subsection{The Aesalon framework}
The Aesalon framework is segregated into two separate sections.
\flushleft
\begin{description}
 \item[\textnormal{The} Monitor] is responsible for launching the process in question. It also loads the polisher
modules
  and parses any ELF and DWARF information present inside the executable file. Any data processed by the
  monitor modules is then sent over a network connection to the Visualizer and/or written to a logfile.
 \item[\textnormal{The} Visualizer] provides a GUI, reads from the network and/or a logfile, and provides storage and
rendering
  frameworks for the renderer modules that it loads.
\end{description}

Overall, the framework is relatively bare-bones; much of the processing etc. is done by the modules themselves.

\subsection{The modules}
Each module is split into three separate sections.
\flushleft
\begin{description}
 \item[\textnormal{The} collector module] is loaded into the address space of the process being monitored; as such, the
  data is collected here, and transferred to the Monitor by a shared memory map.
 \item[\textnormal{The} polisher module] is loaded by the Monitor into the Monitor's address space. Here, the raw data
collected by the Collector is refined slightly. For example, raw function addresses might be processed into C-style
scope names.
 \item[\textnormal{The} renderer module] stores and visualizes the data processed by the monitor; it is loaded into the
address space of the Visualizer.
\end{description}

\section{Communication methods used}
Several methods are used to communicate between the various sections.
\flushleft
\begin{description}
 \item[SHM (SHared Memory)] is used to communicate between the collector modules and the monitor;
 \item[\textnormal{A} TCP network socket] is used to communicate between the monitor and visualizer when operating in
  real-time mode.
\end{description}